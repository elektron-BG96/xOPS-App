<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="About" xml:space="preserve">
    <value>该应用程序将计算小数（浮点数）或整数在给定的秒内CPU可以执行多少次操作（加载数，加，减，乘，除，比较）：

•FLOPS-每秒浮点操作数，浮点单元（FPU）的性能度量。
•INOPS-每秒整数运算，算术逻辑单元（ALU）的度量

例如。 1 GigaFLOPS表示CPU每秒可以执行10亿个浮点运算（例如1.1 + 2.2 = 3.3）。

这些操作实质上是CPU在运行应用程序时始终执行的操作。一般应用程序逻辑通常依赖于整数运算，而图形和游戏则依赖浮点运算。 CPU处理数字的速度越快，应用程序运行的速度就越快。

FPU和ALU测试都在单线程和多线程模式下执行，它们反映了CPU的多核和单核性能。

测试是“隔离的”，这意味着它们仅专注于创建CPU负载（即FPU和ALU），而试图消除来自系统其他部分（例如内存，缓存，存储，网络，软件优化等）的干扰。 ）。有很多因素决定着系统的性能和CPU，尽管不是唯一的因素。虽然该应用程序未对“手机/笔记本电脑/ PC有多快？”的问题给出简单的答案（或分数）。 （甚至可能吗？），它提供了与您设备的一个重要部分-CPU相当的性能指标。

您可以使用以下链接找到有关该应用程序的更多信息以及其他操作系统（Android / ChromeOS，Windows，macOS）的下载版本：</value>
  </data>
  <data name="Options" xml:space="preserve">
    <value>选项</value>
  </data>
  <data name="Close" xml:space="preserve">
    <value>关闭</value>
  </data>
  <data name="CountdownMany" xml:space="preserve">
    <value>在{0}秒内开始测试  </value>
  </data>
  <data name="CountdownOne" xml:space="preserve">
    <value>从1秒开始</value>
  </data>
  <data name="Floating" xml:space="preserve">
    <value>浮点数</value>
  </data>
  <data name="Integer" xml:space="preserve">
    <value>整数</value>
  </data>
  <data name="ST" xml:space="preserve">
    <value>单线程</value>
  </data>
  <data name="MT" xml:space="preserve">
    <value>多线程</value>
  </data>
  <data name="Break" xml:space="preserve">
    <value>¾ 中断</value>
  </data>
  <data name="Retry" xml:space="preserve">
    <value>↻ 重试</value>
  </data>
  <data name="Share" xml:space="preserve">
    <value>↪ 分享</value>
  </data>
  <data name="Running" xml:space="preserve">
    <value>正在运行...</value>
  </data>
  <data name="TestInterrupted" xml:space="preserve">
    <value>测试中断</value>
  </data>
  <data name="Precision" xml:space="preserve">
    <value>精度</value>
  </data>
  <data name="ThreadsNumber" xml:space="preserve">
    <value>线程数</value>
  </data>
  <data name="Bit" xml:space="preserve">
    <value>位</value>
  </data>
  <data name="AveragesMany" xml:space="preserve">
    <value>显示平均值，{0}个测试</value>
  </data>
  <data name="AveragesOne" xml:space="preserve">
    <value>1个测试</value>
  </data>
  <data name="Stress" xml:space="preserve">
    <value>≈ 压力测试</value>
  </data>
</root>